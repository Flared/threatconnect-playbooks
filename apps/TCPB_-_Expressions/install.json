{
  "allowOnDemand": true,
  "appId": "24a7eda9-f279-5671-b0f6-26b0f7f01a6d",
  "displayName": "Expressions",
  "features": [
    "aotExecutionEnabled",
    "appBuilderCompliant",
    "fileParams",
    "secureParams",
    "layoutEnabledApp"
  ],
  "labels": [],
  "languageVersion": "3.6",
  "listDelimiter": "|",
  "note": "This application parses expressions and returns expression results.  The expression\ngrammar is similar to Python, but not exactly identical.  See ebnf-syntax below for the\ncomplete extended Bachus Naur format of the grammar.  Some notable differences from\nPython syntax are no methods on objects or variables, no list comprehensions.\n\nConstants are case-insensitive, although any variables defined from loops are\ncase sensitive, as are attributes or dictionary keys.\n\nThreatConnect variables (e.g. `#App:1234:variable!String`) are evaluated on resolution\nto determine if they are valid expressions, and the expression result is used\nif they are.  If a variable is a string, it will be coerced to a float or an integer\non demand by most functions that expect float or integer arguments.  Note that JSON\ndata is expression grammar compatible, so an expression like\n`#App:1234:json_object!String.field` is valid so long as `json_object` is a JSON\ndictionary.\n\n## Actions\n\n### Evaluate\n\nA direct evaluation of an expression with either single or multiple results.\n\n### Evaluate Many\n\nPerform multiple evaluations, one set to define variables, another to define outputs.\n\n### Evaluate in Loop\n\nLoop evaluation of the same expression while looping over the inputs. Inputs with the same length are incremented in parallel.  The order of loop increments is shortest to longest.\n\n### Evaluate Many With Loop\n\nPerform multiple evaluations, one set to define variables, another to define outputs. Loop variables with the same number of elements will be incremented concurrently, otherwise variables are incremented from shortest number of elements to largest.\nExample: If `a` is `(1,2,3)` and `b` is `(1,2,3)` and `c` is `(1,2)`, a loop expression `(a,b,c)` will yield `[(1,1,1), (1,1,2), (2,2,1), (2,2,2), (3,3,1), (3,3,2)]`\n\n\n\n\n# Builtins\n\n\n## Constants\n\n  * e = 2.718281828459045\n  * pi = 3.141592653589793\n  * tau = 6.283185307179586\n  * urlre = Regular Expression\n\n        \\b\n          # Word cannot begin with special characters\n          (?<![@.,%&#-])\n          # Protocols are optional, but take them with us if they are present\n          (?P<protocol>\\w{2,10}:\\/\\/)?\n          # Domains have to be of a length of 1 chars or greater\n          ((?:\\w|\\&\\#\\d{1,5};)[.-]?)+\n          # The domain ending has to be between 2 to 15 characters\n          (\\.([a-z]{2,15})\n               # If no domain ending we want a port, only if a protocol is specified\n               |(?(protocol)(?:\\:\\d{1,6})|(?!)))\n        \\b\n        # Word cannot end with @ (made to catch emails)\n        (?![@])\n        # We accept any number of slugs, given we have a char after the slash\n        (\\/)?\n        # If we have endings like ?=fds include the ending\n        (?:([\\w\\d\\?\\-=#:%@&.;])+(?:\\/(?:([\\w\\d\\?\\-=#:%@&;.])+))*)?\n        # The last char cannot be one of these symbols .,?!,- exclude these\n        (?<![.,?!-])\n\n## Functions\n\n  * `abs(x)`\n\n    Absolute value of X\n\n  * `acos(x)`\n\n    Arc Cosine of X\n\n  * `acosh(x)`\n\n    Inverse Hyperbolic Cosine\n\n  * `asin(x)`\n\n    Arc Sine of X\n\n  * `asinh(x)`\n\n    Inverse Hyperbolic Sine\n\n  * `atan(x)`\n\n    Arc Tangent of X\n\n  * `atanh(x)`\n\n    Inverse Hyperbolic Tangent\n\n  * `b64decode(s, altchars=None, validate=False, encoding='utf-8')`\n\n    Base 64 decode of string\n\n  * `b64encode(s, altchars=None, encoding='utf-8')`\n\n    Base 64 encode of string\n\n  * `bytes(s, encoding='utf-8', errors=None)`\n\n    Convert object to binary string (bytes)\n\n  * `ceil(x)`\n\n    Ceiling of X\n\n  * `center(s, width, fillchar=' ')`\n\n    Center string in width columns\n\n  * `choice(condition, true_result=None, false_result=None)`\n\n    Choice of true_result or false_result based on condition\n\n  * `chr(x)`\n\n    Return character value of x\n\n  * `copysign(x, y)`\n\n    Copy sign of X to Y\n\n  * `cos(x)`\n\n    Cosine of X\n\n  * `cosh(x)`\n\n    Hyperbolic Cosine\n\n  * `csvread(data, header=False, convert=True, delimiter=',', quote='\"', rows=0, columns=0)`\n\n    Process data as a CSV File.  Return the data as a list of rows of columns,\n    or if rows=1, return a list of columns).  If header is true, the first record\n    is discarded.  If rows or columns is nonzero, the row or column count will\n    be truncated to that number of rows or columns. If convert is True, numeric\n    values will be returned as numbers, not strings\n\n  * `csvwrite(data, delimiter=',', quote='\"')`\n\n    Write data in CSV format.  Returns a string\n\n  * `datetime(datetime, date_format=None, tz=None)`\n\n    Format a datetime object according to a format string\n\n  * `degrees(x)`\n\n    Convert X to degrees\n\n  * `erf(x)`\n\n    Error Function of X\n\n  * `erfc(x)`\n\n    Complimentary Error Function of X\n\n  * `exp(x)`\n\n    Math Exp of X\n\n  * `expm1(x)`\n\n    Math Expm1 of X\n\n  * `factorial(x)`\n\n    Factorial of X\n\n  * `find(ob, value, start=None, stop=None)`\n\n    Find index value in ob or return -1\n\n  * `flatten(ob, prefix='')`\n\n    Flatten a possibly nested list of dictionaries to a list, prefixing keys with prefix\n\n  * `float(s)`\n\n    Return floating point value of object\n\n  * `format(s, *args, **kwargs)`\n\n    Format string S according to Python string formatting rules.  Compound structure elements are\n    access with bracket notation and without quotes around key names, e.g. `blob[0][events][0][source][device][ipAddress]`\n\n  * `fuzzydist(hash1, hash2)`\n\n    Return the edit distance between two fuzzy hashes\n\n  * `fuzzyhash(data)`\n\n    Return the fuzzy hash of data\n\n  * `fuzzymatch(input1, input2)`\n\n    Return a score from 0..100 representing a poor match (0) or\n    a strong match(100) between the two inputs\n\n  * `gamma(x)`\n\n    Return the gamma function at X\n\n  * `gcd(a, b)`\n\n    Greatest Common Denominator of A and B\n\n  * `hypot(x, y)`\n\n    Hypotenuse of X,Y\n\n  * `index(ob, value, start=None, stop=None)`\n\n    Index of value in ob\n\n  * `int(s)`\n\n    Return integer value of object\n\n  * `items(ob)`\n\n    Items (key, value pairs) of dictionary\n\n  * `jmespath(path, ob)`\n\n    JMESPath search\n\n  * `join(separator, *elements)`\n\n    Join a list with separator\n\n  * `json_dump(ob, sort_keys=True, indent=2)`\n\n    Dump an object to a JSON string\n\n  * `json_load(ob)`\n\n    Load an object from a JSON string\n\n  * `keys(ob)`\n\n    Keys of dictionary\n\n  * `len(container)`\n\n    Length of an iterable\n\n  * `lgamma(x)`\n\n    Return the natural logarithm of the absolute value of the gamma function at X\n\n  * `locale_currency(val, symbol=True, grouping=False, international=False, locale='EN_us')`\n\n    Format a currency value according to locale settings\n\n  * `locale_format(fmt, val, grouping=False, monetary=False, locale='EN_us')`\n\n    Format a nubmer according to locale settings\n\n  * `log(x, base=None)`\n\n    Math Logarithm of X to base\n\n  * `log10(x)`\n\n    Math log base 10 of X\n\n  * `log1p(x)`\n\n    Math log1p of x\n\n  * `log2(x)`\n\n    Math log base 2 of X\n\n  * `lower(s)`\n\n    Lowercase string\n\n  * `lstrip(s, chars=None)`\n\n    Strip chars from left of string\n\n  * `max(*items)`\n\n    Return the greatest value of the list\n\n  * `md5(data)`\n\n    Return MD5 hash of data\n\n  * `min(*items)`\n\n    Return the least value of the list\n\n  * `namevallist(ob, namekey='name', valuekey='value')`\n\n    Return a dictionary formatted as a list of name=name, value=value dictionaries\n\n  * `ord(char)`\n\n    Return ordinal value of char\n\n  * `pad(iterable, length, padvalue=None)`\n\n    Pad iterable to length\n\n  * `pformat(ob, indent=1, width=80, compact=False)`\n\n    Pretty formatter for displaying hierarchial data\n\n  * `pow(x, y)`\n\n    Math X ** Y\n\n  * `printf(fmt, *args)`\n\n    Format arguments according to format\n\n  * `radians(x)`\n\n    Convert X to radians\n\n  * `range(start_or_stop, stop=None, step=None)`\n\n    Return range of values\n\n  * `refindall(pattern, string, flags='')`\n\n    Find all instances of the regular expression in source\n\n  * `rematch(pattern, string, flags='')`\n\n    Regular expression match pattern to source\n\n  * `replace(s, source, target)`\n\n    Replace chars on S\n\n  * `research(pattern, string, flags='')`\n\n    Regular expression search pattern to source\n\n  * `rstrip(s, chars=None)`\n\n    Strip chars from right of string\n\n  * `sha1(data)`\n\n    Return SHA1 hash of data\n\n  * `sha256(data)`\n\n    Return SHA256 hash of data\n\n  * `sin(x)`\n\n    Sine of X\n\n  * `sinh(x)`\n\n    Hyperbolic Sine\n\n  * `sort(*elements)`\n\n    Sort array\n\n  * `split(string, separator=None, maxsplit=-1)`\n\n    Split a string into elements\n\n  * `sqrt(x)`\n\n    Square root of X\n\n  * `str(s)`\n\n    Return string representation of object\n\n  * `strip(s, chars=None)`\n\n    Strip chars from ends of string\n\n  * `sum(*elements)`\n\n    Sum a list of elements\n\n  * `tan(x)`\n\n    Tangent of X\n\n  * `tanh(x)`\n\n    Hyperbolic Tangent\n\n  * `timedelta(datetime_1, datetime_2)`\n\n    Return the delta between time 1 and time 2\n\n  * `title(s)`\n\n    Title of string\n\n  * `trunc(x)`\n\n    Math Truncate X\n\n  * `unique(*args)`\n\n    Return the list of unique elements of arguments, which may be a list of arguments, or a\n    single argument that is a list.  Inputs are compared by converting them to\n    sorted JSON objects, so dictionaries with the same keys and values but different\n    order will count as duplicates.\n\n  * `unnest(iterable)`\n\n    Reduces nested list to a single flattened list.  [A, B, [C, D, [E, F]]\n    turns into [A, B, C, D, E, F].\n\n  * `upper(s)`\n\n    Uppercase string\n\n  * `urlparse(urlstring, scheme='', allow_fragments=True)`\n\n    Parse a URL into a six component named tuple\n\n  * `urlparse_qs(qs, keep_blank_values=False, strict_parsing=False, encoding='utf-8', errors='replace', max_num_fields=None)`\n\n    Parse a URL query string into a dictionary.  Each value is a list.\n\n  * `values(ob)`\n\n    Values of dictionary\n\n\n\n# EBNF-Syntax\n\n    The grammar for the expressions is below.  Production rules are prefixed by -> and are used\n    to tell the parser what to do when that construct is identified.\n\n    start:  eval\n\n    eval: sum\n        | eval \"||\" sum -> logical_or\n        | eval \"&&\" sum -> logical_and\n        | eval \"or\" sum -> logical_or\n        | eval \"and\" sum -> logical_and\n        | eval \"==\" sum -> equals\n        | eval \"!=\" sum -> not_equals\n        | eval \"<\" sum -> less_than\n        | eval \">\" sum -> greater_than\n        | eval \"<=\" sum -> less_than_equal_to\n        | eval \">=\" sum -> greater_than_equal_to\n        | \"not\" eval -> not_\n        | eval \"in\" product -> in_\n        | eval \"not\" \"in\" product -> not_in_\n\n    sum: product\n        | sum \"+\" product -> add\n        | sum \"-\" product -> sub\n\n    product: raise\n        | product \"*\" raise -> mul\n        | product \"/\" raise -> div\n        | product \"%\" raise -> mod\n\n    raise: atom\n        | raise \"**\" atom -> pow\n\n    atom: FLOAT    -> num_float\n        | INT       -> num_int\n        | \"-\" atom  -> neg\n        | NAME      -> var\n        | string\n        | \"(\" eval_list \")\" -> tuple_freeze\n        | \"[\" eval_list \"]\" -> list_freeze\n        | \"{\" dict_list \"}\" -> dict_freeze\n        | NAME \"(\" arg_list \")\" -> function\n        | atom \"[\" atom \"]\" -> get\n        | atom \"[\" optional_atom \":\" optional_atom \"]\" -> get_slice\n        | atom \".\" NAME -> getattr\n\n    string: STRING     -> literal_\n        | TCVARIABLE    -> tcvariable\n        | SQUOTE_STRING -> literal_\n        | string string -> concat_string\n\n    dict_list: dict_assign         -> list_\n        | dict_list \",\" dict_assign -> list_\n        |                           -> list_\n\n    dict_assign: eval \":\" eval -> set_kwarg\n\n    eval_list: eval\n        | eval_list \",\" eval -> list_\n        | eval_list \",\"      -> list_\n        |                    -> list_\n\n    arg: eval\n        | NAME \"=\" eval -> set_kwarg\n\n    arg_list: arg\n        | arg_list \",\" arg  -> list_\n        | arg_list \",\"      -> list_\n        |                   -> list_\n\n    optional_atom:  atom\n        | -> none\n\n    TCVARIABLE: /#[A-Za-z]+:\\d+:[A-Za-z0-9_.]+!\\w+/\n    _STRING_INNER: /.*?/\n    _STRING_ESC_INNER: _STRING_INNER /(?<!\\\\)(\\\\\\\\)*?/\n    SQUOTE_STRING: \"'\" _STRING_ESC_INNER \"'\"\n\n",
  "params": [
    {
      "label": "Action",
      "name": "tc_action",
      "note": "The action to take",
      "required": true,
      "sequence": 1,
      "type": "Choice",
      "validValues": [
        "Evaluate",
        "Evaluate Many",
        "Evaluate in Loop",
        "Evaluate Many With Loop"
      ]
    },
    {
      "label": "Expression",
      "name": "expression",
      "note": "The expression to evaluate.  If the expression is a list,\ne.g. (\"foo\", 1, 5.0) the output will be a StringArray.",
      "playbookDataType": [
        "String",
        "StringArray"
      ],
      "required": true,
      "sequence": 2,
      "type": "String",
      "validValues": [
        "${TEXT}"
      ]
    },
    {
      "label": "Variables",
      "name": "variables",
      "note": "Variables to be defined for the expressions to reference.  Defined variables are\nnot output.  Variables are evaluated in the order they are entered.",
      "playbookDataType": [
        "String",
        "StringArray"
      ],
      "sequence": 3,
      "type": "KeyValueList",
      "validValues": [
        "${TEXT}"
      ]
    },
    {
      "label": "Loop Variables",
      "name": "loop_variables",
      "note": "Add a name and a value for each variable to loop over.   Loop variables with\nthe same number of elements will be incremented concurrently, variables with\ndifferent number of elements will be nested from longest to shortest.",
      "playbookDataType": [
        "String",
        "StringArray"
      ],
      "required": true,
      "sequence": 4,
      "type": "KeyValueList",
      "validValues": [
        "${TEXT}"
      ]
    },
    {
      "exposePlaybookKeyAs": "StringArray",
      "label": "Loop Expressions",
      "name": "loop_expressions",
      "note": "Loop outputs and loop output expressions for each output.  These may reference defined variables\nbut may not refer to other loop variables or outputs.",
      "playbookDataType": [
        "String",
        "StringArray"
      ],
      "required": true,
      "sequence": 5,
      "type": "KeyValueList",
      "validValues": [
        "${TEXT}"
      ]
    },
    {
      "exposePlaybookKeyAs": "String",
      "label": "Additional Outputs",
      "name": "additional_outputs",
      "note": "Outputs and output expressions for each output.  These may reference defined\nvariables and loop outputs, but may not refer to outputs not yet evaluated.\nOutputs will be generated as a single output only, with list outputs being converted to\nJSON strings.",
      "playbookDataType": [
        "String",
        "StringArray"
      ],
      "sequence": 6,
      "type": "KeyValueList",
      "validValues": [
        "${TEXT}"
      ]
    },
    {
      "label": "Expression",
      "name": "loop_expression",
      "note": "The expression to evaluate.  If the expression generates a list result,\neach element of the step-wise evaluation will be appended to the final result.",
      "playbookDataType": [
        "String",
        "StringArray"
      ],
      "required": true,
      "sequence": 7,
      "type": "String",
      "validValues": [
        "${TEXT}"
      ]
    },
    {
      "exposePlaybookKeyAs": "String",
      "label": "Outputs",
      "name": "outputs",
      "note": "Outputs and output expressions for each output.  These may reference defined variables\nbut may not refer to outputs not yet evaluated.  Outputs will be generated as a\nsingle output only, with list outputs being converted to JSON strings.",
      "playbookDataType": [
        "String"
      ],
      "required": true,
      "sequence": 8,
      "type": "KeyValueList",
      "validValues": [
        "${TEXT}"
      ]
    },
    {
      "default": true,
      "label": "Return None on failure",
      "name": "return_none_on_failure",
      "note": "When an expression fails to evaluate, assign it the value None, and continue\nexecution.",
      "sequence": 9,
      "type": "Boolean"
    }
  ],
  "playbook": {
    "outputVariables": [
      {
        "name": "expression.expression",
        "type": "String"
      },
      {
        "name": "expression.result.0",
        "type": "String"
      },
      {
        "name": "expression.result.array",
        "type": "StringArray"
      },
      {
        "name": "expression.action",
        "type": "String"
      },
      {
        "name": "expression.errors",
        "type": "StringArray"
      }
    ],
    "type": "Utility"
  },
  "programLanguage": "PYTHON",
  "programMain": "run",
  "programVersion": "1.0.5",
  "runtimeLevel": "Playbook"
}
